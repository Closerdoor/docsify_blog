## 时间复杂度
可以简单理解成重复执行代码的次数(或者说循环的次数)，如果有不同阶数的代码块，则只取最高级

- 普通for循环的时间复杂度——O(n)
- 数组的访问——O(1)
    数据的寻址跟数据量无关，只需要计算一个偏移量(距离)，因为数组的内存是连续的。而链表如果要获取i位置的值则需要从左往右遍历
- 链表的插入和删除——O(1)
- 数组的查找——O(n)
- 折半查找——O(log₂n)
- 冒泡/选择/插入/快速排序——O(n²)
- 归并排序——O(nlogn)

题目:下列for循环运算时间复杂度分别为?
```js
for(var i = 0; i < arr.length; i++){
    console.log(arr[i]);
}
//O(n²+1)
for(var i = 0, len = arr.length; i < len; i++){
    console.log(item);
}
//O(n+1)
for(var i = 0,item;item = arr[i++];){
    console.log(item);
}
//O(n)
```

## 递归的时间复杂度
master公式
T(n) = a * T(n/b) + O(nⁿ)

- T(n) 中n指总数据量
- T(n/b)中b表示每次递归拆分成的等量数据的数量
- a表示拆分的等量数据要执行几次
- O(nⁿ)表示除开递归内容其余内容的执行次数
  
结果：
- 如果log(b,a) > d，复杂度为O(n^log(b,a))
- 如果log(b,a) < d，复杂度为O(n^d)
- 如果log(b,a) == d，复杂度为O(n^d * logn)
## 空间复杂度
算法在执行时需要额外占用的内存空间