## javascript 中的位运算

位运算是在数字底层（即表示数字的 32 个数位）进行运算的。由于位运算是低级的运算操作，所以速度往往也是最快的（相对其它运算如加减乘除来说），并且借助位运算有时我们还能实现更简单的程序逻辑,缺点是很不直观，许多场合不能够使用。

## 常用位操作

取出最右侧的 1

```js
let a = 700;
let right = a & (~a + 1);
/*  解析
a     1010111100
~a    0101000011
~a+1  0101000100
right 0000000100
 */
```

## 逻辑位运算符：& (位与)

真真为真（1），其余为假（0）

> 注意： 位运算 与 可以用于 b 中是否包含 a ,这个包含是指的是二进制的数据是否包含交集，具体的表达式如下： (a & b) === a

```js
//奇数的二进制码的最后一位数肯定是1, 而1只有最后一位为1, 按位与运算后, 结果肯定只有最后一位数是1. 而偶数的二进制表示的最后一位数是0, 和1进行按位与运算, 结果的所有位都是0.
function assert(n) {
  if (n & 1) {
    console.log("n是奇数");
  } else {
    console.log("n是偶数");
  }
}
assert(3); // n是奇数
```

## 逻辑位运算符：| (位或)

假假为假（0），其余为真（1）

使用场景示例:
一般常用来取两个二进制数据的并集
对浮点数向下求整

```js
var num = Math.floor(1.1);    // 1
var num = 1.1 | 0;            // 1
其实浮点数是不支持位运算的, 所以会先把小数位丢弃, 然后以整数进行位运算, 而任何数与0进行按位或操作, 结果都是它本身, 就好像是对浮点数向下求整.
```

## 逻辑位运算符：^ (异或)

相同为假（0），不同为真（1）
异或满足交换律和结合律, 数字与它本身进行异或操作, 得到 0; 数字与 0 进行异或操作, 得到它本身.

```js
//a:10110
//b:00111
//^ 10001
//0和任何一个数异或都得到N
0 ^ n = n;
//任何一个数和自己异或得到0
n ^ n = 0
//交换两个变量数字的值
//使用此方法的前期是两个变量内存地址不同，如果相同，会直接异或成0
let a = 17,b=10;
a = a ^ b;
b = a ^ b;
a = a ^ b;
```

## 逻辑位运算符：~ (非)

将操作数转换为二进制数, 然后按位求反.

浮点数是不支持位运算的，所以会先直接去除小数部分，转成整数再进行位运算，就好像是对浮点数向下求整.
~~可以进行类型转换,位运算会默认将非数字类型转换成数字类型再进行运算 （转换结果为整数 直接去除小数部分）

```js
~~true == 1;
~~false == 0;
~~"" == 0;
~~"all" == 0;
~~"32all" == 0;
~~"all43" == 0;
~~[] == 0;
~~undefined == 0;
~~!undefined == 1;
~~null == 0;
~~!null == 1;
~~5.9 == 5;
~~5.2 == 5;
~~-5.9 == -5;
// 以上所有结果都为true
```

## 移位运算符：左移（<<）、右移（>>）、全右移（>>>）
